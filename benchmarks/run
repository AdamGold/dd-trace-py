#!/usr/bin/env python
import collections
import contextlib
import glob
import json
import os
import platform
import subprocess
import sys
import typing


@contextlib.contextmanager
def cwd(path):
    # type: (str) -> None
    original = os.getcwd()
    os.chdir(path)
    try:
        yield
    finally:
        os.chdir(original)


def print_result_row(fields):
    # type: (typing.List[str]) -> None
    parts = ["{:>20}"] * len(fields)
    format_str = "|" + "|".join(parts) + "|"
    print(format_str.format(*fields))


def run_sirun(meta_path, variant=None):
    # type: (str, typing.Optional[str]) -> typing.Dict[str, typing.Any]
    env = os.environ.copy()
    if variant:
        env["SIRUN_VARIANT"] = variant

    args = ["sirun", meta_path]

    with cwd(os.path.dirname(meta_path)):
        output = subprocess.check_output(args, env=env)

    # Grab the last line of output
    sirun_data = [l.strip() for l in output.splitlines() if l.strip()][-1]
    # DEV: Python 3.5 `json.loads` does not accept `bytes` or `bytearray`
    if sys.version_info.major == 3 and sys.version_info.minor == 5:
        sirun_data = sirun_data.decode("utf-8")
    results = json.loads(sirun_data)

    # If there is only 1 iteration we don't get a list of iterations
    #   turn
    # {"name": "test", "sys.time": 5, "max.rss": 20, ...}
    #   into
    # {"name": "test", "iterations": [{"sys.time": 5, ...}]}
    if "iterations" not in results:
        iteration = dict()
        new_results = dict(iterations=[iteration])
        for key, value in results.items():
            if key in ("name", "variant", "instructions"):
                new_results[key] = value
            else:
                iteration[key] = value
        results = new_results

    # Make sure the list of keys is consistent, even if we don't have any data
    for key in ("name", "variant", "instructions"):
        if key not in results:
            results[key] = None

    # Add additional metadata
    results["python"] = dict(
        major=sys.version_info.major,
        minor=sys.version_info.minor,
        micro=sys.version_info.micro,
        name=platform.python_implementation(),
    )
    system, node, release, _, machine, _ = platform.uname()
    results["platform"] = dict(
        system=system,
        node=node,
        release=release,
        machine=machine,
    )

    return results


def run_suite(suite_dir):
    # type: (str) -> typing.Dict[str, typing.Dict[str, typing.Any]]:
    meta_path = os.path.join(suite_dir, "meta.json")
    if not os.path.isfile(meta_path):
        raise FileNotFoundError("Suite meta path {!r} does not exist".format(meta_path))

    with open(meta_path, "r") as fp:
        meta_data = json.load(fp)

    variants = meta_data.get("variants")
    if not variants:
        variants = [None]
    else:
        variants = variants.keys()

    results = collections.OrderedDict()
    for i, variant in enumerate(sorted(variants), start=1):
        print("[{}/{}] Variant: {}".format(i, len(variants), variant))
        results[variant] = run_sirun(meta_path, variant=variant)

    return results


def main(base_dir, suites):
    # type: (str, typing.List[str]) -> None

    # No suites provided, go find all of them to run
    if not suites:
        suites = [os.path.basename(fname) for fname in glob.glob(os.path.join(base_dir, "*")) if os.path.isdir(fname)]

    # Run our benchmark suites
    results = collections.OrderedDict()
    for i, suite_name in enumerate(sorted(suites), start=1):
        print("[{}/{}] Suite: {}".format(i, len(suites), suite_name))
        suite_dir = os.path.join(base_dir, suite_name)
        results[suite_name] = run_suite(suite_dir)

    # Write full results as json file
    results_dir = os.path.join(base_dir, "results")
    if not os.path.isdir(results_dir):
        os.makedirs(results_dir)
    results_filename = os.path.join(results_dir, "results-{}-{}.json".format(platform.python_version(), os.getpid()))
    with open(results_filename, "w") as fp:
        json.dump(results, fp)
    print("Results JSON: {}".format(results_filename))

    # Print results as a table
    for suite, variants in results.items():

        print("Results: {}".format(suite))
        print_result_row(
            (
                "Python",
                "Variant",
                "Iterations",
                "Instructions",
                "max.res.size min",
                "max.res.size max",
                "max.res.size mean",
                "wall.time min",
                "wall.time max",
                "wall.time mean",
            )
        )

        for variant, data in variants.items():
            metrics = collections.defaultdict(list)
            for iteration in data["iterations"]:
                for metric, value in iteration.items():
                    metrics[metric].append(value)

            iterations = len(data["iterations"])
            print_result_row(
                [
                    "{}.{}.{}".format(
                        data["python"]["major"],
                        data["python"]["minor"],
                        data["python"]["micro"],
                    ),
                    variant,
                    iterations,
                    data["instructions"],
                    min(metrics["max.res.size"]),
                    max(metrics["max.res.size"]),
                    sum(metrics["max.res.size"]) / float(iterations),
                    min(metrics["wall.time"]),
                    max(metrics["wall.time"]),
                    sum(metrics["wall.time"]) / float(iterations),
                ]
            )


if __name__ == "__main__":
    base_dir = os.path.abspath(os.path.dirname(__file__))
    main(base_dir, sys.argv[1:])
