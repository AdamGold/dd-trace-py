import redis
import rq

from ddtrace import Pin
from ddtrace.contrib.rq import patch
from tests.base import BaseTracerTestCase


def job1(x):
    return x + 1


def job2():
    raise Exception('error')


class TestRqTracingNotAsync(BaseTracerTestCase):
    """
    Test the rq integration with a non-async queue. This will execute jobs without
    a worker.
    """
    def setUp(self):
        super(TestRqTracingNotAsync, self).setUp()
        patch()
        self.r = redis.Redis()
        self.q = rq.Queue('queue-name', is_async=False, connection=self.r)
        Pin.override(rq, tracer=self.tracer)
        Pin.override(rq.job, tracer=self.tracer)
        Pin.override(rq.queue, tracer=self.tracer)
        Pin.override(rq.worker, tracer=self.tracer)

    def test_enqueue(self):
        self.q.enqueue(job1, 1)
        spans = self.get_spans()
        assert len(spans) == 2

        span = spans[0]
        assert span.name == 'rq.queue.enqueue_job'
        assert span.service == 'rq'
        assert span.error == 0
        assert span.get_tag('job.id')
        assert span.get_tag('job.func_name') == 'tests.contrib.rq.test_trace.job1'
        assert span.get_tag('job.status') == 'finished'

        span = spans[1]
        assert span.name == 'rq.job.perform'
        assert span.service == 'rq-worker'
        assert span.error == 0

    def test_failing_job(self):
        try:
            self.q.enqueue(job2)
        except Exception:
            pass
        spans = self.get_spans()
        assert len(spans) == 2


class TestRqTracingAsync(BaseTracerTestCase):
    def setUp(self):
        super(TestRqTracingAsync, self).setUp()
        patch()
        self.r = redis.Redis()
        self.q = rq.Queue('queue-name', connection=self.r)
        self.w = rq.Worker([self.q], connection=self.r)
        Pin.override(rq, tracer=self.tracer)
        Pin.override(rq.job, tracer=self.tracer)
        Pin.override(rq.queue, tracer=self.tracer)
        Pin.override(rq.worker, tracer=self.tracer)

    def test_simple_job_run(self):
        self.q.enqueue(job1, 1)
        self.w.work(burst=True)
        spans = self.get_spans()
        assert len(spans) == 2
        # TODO: the spans generated by the worker (which forks off to run the task)
        #       cannot be captured here


